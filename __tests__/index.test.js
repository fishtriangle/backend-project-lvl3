import path from 'path';
import { fileURLToPath } from 'url';
import { readFile as readFilePromise } from 'node:fs/promises';
import {
  test,
  expect,
  describe,
  beforeAll,
  beforeEach,
  afterEach,
} from '@jest/globals';
import mock from 'mock-fs';
import nock from 'nock';
import { minify } from 'html-minifier';

import loadPage from '../src/index.js';
import ParsedHTML from '../src/parsedHTML.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const getFixturePath = (filename) => path.join(__dirname, '..', '__fixtures__', filename);
const readFixture = (filename) => readFilePromise(getFixturePath(filename), 'utf-8');

const customSavePath = path.join(__dirname, '/var/tmp');
const defaultSavePath = process.cwd();

const baseHTMLSrcs = [
  'https://cdn2.hexlet.io/assets/menu.css',
  '/assets/application.css',
  '/courses',
  '/assets/professions/nodejs.png',
  'https://js.stripe.com/v3/',
  'https://ru.hexlet.io/packs/js/runtime.js',
];

const localHTMLSrcs = [
  'https://cdn2.hexlet.io/assets/menu.css',
  'ru-hexlet-io-courses_files/ru-hexlet-io-assets-application.css',
  'ru-hexlet-io-courses_files/ru-hexlet-io-courses.html',
  'ru-hexlet-io-courses_files/ru-hexlet-io-assets-professions-nodejs.png',
  'https://js.stripe.com/v3/',
  'ru-hexlet-io-courses_files/ru-hexlet-io-packs-js-runtime.js',
];

class TestPaths {
  constructor(basePath) {
    this.basePath = basePath;
    this.downloadedFilesPath = path.join(this.basePath, 'ru-hexlet-io-courses_files');
    this.downloadedImgPath = path.join(this.downloadedFilesPath, 'ru-hexlet-io-assets-professions-nodejs.png');
    this.downloadedCssPath = path.join(this.downloadedFilesPath, 'ru-hexlet-io-assets-application.css');
    this.downloadedJsPath = path.join(this.downloadedFilesPath, 'ru-hexlet-io-packs-js-runtime.js');
    this.downloadedHtmlPath = path.join(this.downloadedFilesPath, 'ru-hexlet-io-courses.html');
  }
}

const defaultPaths = new TestPaths(defaultSavePath);
const customPaths = new TestPaths(customSavePath);

const pageURL = new URL('https://ru.hexlet.io/courses');
const minifyConfig = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true,
};

let basePage;
let changedPage;
let baseImg;
let baseCss;
let baseJs;
let returnedFilePath;
let downloadedPage;
let downloadedImg;
let downloadedCss;
let downloadedJs;
let downloadedHtml;

describe('download html file and save it locally', () => {
  beforeAll(async () => {
    nock.disableNetConnect();
    try {
      basePage = await readFixture('htmlToDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlToDownload.html');
      throw new Error(error);
    }
    try {
      changedPage = await readFixture('htmlAfterDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlAfterDownload.html');
      throw new Error(error);
    }
    try {
      baseImg = await readFixture('assets/nodejs.png');
    } catch (error) {
      console.log('Cannot load fixture file: assets/nodejs.png');
      throw new Error(error);
    }
    try {
      baseCss = await readFixture('assets/application.css');
    } catch (error) {
      console.log('Cannot load fixture file: assets/application.css');
      throw new Error(error);
    }
    try {
      baseJs = await readFixture('assets/runtime.js');
    } catch (error) {
      console.log('Cannot load fixture file: assets/runtime.js');
      throw new Error(error);
    }
  });

  beforeEach(() => {
    mock({
      [customSavePath]: {},
      [defaultSavePath]: {},
    });

    nock(/ru\.hexlet\.io/)
      .get(/\/assets\/application\.css/)
      .reply(200, baseCss)
      .get(/\/courses/)
      .twice()
      .reply(200, basePage)
      .get(/\/assets\/professions\/nodejs\.png/)
      .reply(200, baseImg)
      .get(/\/packs\/js\/runtime\.js/)
      .reply(200, baseJs);
  });

  afterEach(() => {
    mock.restore();
  });

  test('default option', async () => {
    try {
      returnedFilePath = await loadPage(pageURL.href);
    } catch (error) {
      console.log('Cannot execute loadPage function');
      throw new Error(error);
    }

    try {
      downloadedPage = await readFilePromise(returnedFilePath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved file');
      throw new Error(error);
    }

    expect(returnedFilePath).toBe(path.join(defaultSavePath, 'ru-hexlet-io-courses.html'));
    expect(minify(downloadedPage, minifyConfig)).toBe(minify(changedPage, minifyConfig));

    try {
      downloadedImg = await readFilePromise(defaultPaths.downloadedImgPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    try {
      downloadedCss = await readFilePromise(defaultPaths.downloadedCssPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    try {
      downloadedJs = await readFilePromise(defaultPaths.downloadedJsPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    try {
      downloadedHtml = await readFilePromise(defaultPaths.downloadedHtmlPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    expect(downloadedImg).toBe(baseImg);
    expect(downloadedCss).toBe(baseCss);
    expect(downloadedJs).toBe(baseJs);
    expect(downloadedHtml).toBe(basePage);
  });

  test('custom option', async () => {
    try {
      returnedFilePath = await loadPage(pageURL.href, customSavePath);
    } catch (error) {
      console.log('Cannot execute pageLoader function');
      throw new Error(error);
    }

    try {
      downloadedPage = await readFilePromise(returnedFilePath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved file');
      throw new Error(error);
    }

    expect(returnedFilePath).toBe(path.join(customSavePath, 'ru-hexlet-io-courses.html'));
    expect(minify(downloadedPage, minifyConfig)).toBe(minify(changedPage, minifyConfig));

    try {
      downloadedImg = await readFilePromise(customPaths.downloadedImgPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    try {
      downloadedCss = await readFilePromise(customPaths.downloadedCssPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    try {
      downloadedJs = await readFilePromise(customPaths.downloadedJsPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    try {
      downloadedHtml = await readFilePromise(customPaths.downloadedHtmlPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    expect(downloadedImg).toBe(baseImg);
    expect(downloadedCss).toBe(baseCss);
    expect(downloadedJs).toBe(baseJs);
    expect(downloadedHtml).toBe(basePage);
  });
});

describe('parse HTML', () => {
  beforeAll(async () => {
    try {
      basePage = await readFixture('htmlToDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlToDownload.html');
      throw new Error(error);
    }
    try {
      changedPage = await readFixture('htmlAfterDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlAfterDownload.html');
      throw new Error(error);
    }
  });

  test('create HTML, getImgSrcs, setImgSrc, get changed HTML', () => {
    const html = new ParsedHTML(basePage);
    expect(minify(html.toString(), minifyConfig)).toBe(minify(basePage, minifyConfig));
    const filesSrcs = html.getFilesSrc();
    // console.log('images srcs before change: ', imagesSrcs);
    expect(filesSrcs).toEqual(baseHTMLSrcs);
    html.setFilesSrc(localHTMLSrcs);
    expect(minify(html.toString(), minifyConfig)).toBe(minify(changedPage, minifyConfig));
  });
});
