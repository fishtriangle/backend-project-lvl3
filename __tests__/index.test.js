import path from 'path';
import { fileURLToPath } from 'url';
import { readFile as readFilePromise } from 'node:fs/promises';
import {
  test,
  expect,
  describe,
  beforeAll,
  beforeEach,
  afterEach,
} from '@jest/globals';
import mock from 'mock-fs';
import nock from 'nock';
import { minify } from 'html-minifier';

import loadPage from '../src/index.js';
import ParsedHTML from '../src/parsedHTML.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const getFixturePath = (filename) => path.join(__dirname, '..', '__fixtures__', filename);
const readFixture = (filename) => readFilePromise(getFixturePath(filename), 'utf-8');

const customSavePath = path.join(__dirname, '/var/tmp');
const defaultSavePath = process.cwd();
const downloadedDefaultImgPath = path.join(defaultSavePath, 'ru-hexlet-io-courses_files/ru-hexlet-io-assets-professions-nodejs.png');
const downloadedCustomImgPath = path.join(customSavePath, 'ru-hexlet-io-courses_files/ru-hexlet-io-assets-professions-nodejs.png');
const pageURL = new URL('https://ru.hexlet.io/courses');
const minifyConfig = {
  includeAutoGeneratedTags: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: true,
  useShortDoctype: true,
  collapseWhitespace: true,
};

let baseHTML;
let changedHTML;
let baseImg;
let returnedFilePath;
let downloadedHTML;
let downloadedImg;

describe('download html file and save it locally', () => {
  beforeAll(async () => {
    nock.disableNetConnect();
    try {
      baseHTML = await readFixture('htmlToDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlToDownload.html');
      throw new Error(error);
    }
    try {
      changedHTML = await readFixture('htmlAfterDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlAfterDownload.html');
      throw new Error(error);
    }
    try {
      baseImg = await readFixture('assets/professions/nodejs.png');
    } catch (error) {
      console.log('Cannot load fixture file: assets/professions/nodejs.png');
      throw new Error(error);
    }
  });

  beforeEach(() => {
    mock({
      [customSavePath]: {},
      [defaultSavePath]: {},
    });

    nock(/ru\.hexlet\.io/)
      .get(/\/courses/)
      .reply(200, baseHTML)
      .get(/\/assets\/professions\/nodejs\.png/)
      .reply(200, baseImg);
  });

  afterEach(() => {
    mock.restore();
  });

  test('default option', async () => {
    try {
      returnedFilePath = await loadPage(pageURL.href);
    } catch (error) {
      console.log('Cannot execute loadPage function');
      throw new Error(error);
    }

    try {
      downloadedHTML = await readFilePromise(returnedFilePath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved file');
      throw new Error(error);
    }

    try {
      downloadedImg = await readFilePromise(downloadedDefaultImgPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    expect(returnedFilePath).toBe(path.join(defaultSavePath, 'ru-hexlet-io-courses.html'));
    expect(minify(downloadedHTML, minifyConfig)).toBe(minify(changedHTML, minifyConfig));
    expect(downloadedImg).toBe(baseImg);
  });

  test('custom option', async () => {
    try {
      returnedFilePath = await loadPage(pageURL.href, customSavePath);
    } catch (error) {
      console.log('Cannot execute pageLoader function');
      throw new Error(error);
    }

    try {
      downloadedHTML = await readFilePromise(returnedFilePath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved file');
      throw new Error(error);
    }

    try {
      downloadedImg = await readFilePromise(downloadedCustomImgPath, 'utf-8');
    } catch (error) {
      console.log('Cannot read saved img');
      throw new Error(error);
    }

    expect(returnedFilePath).toBe(path.join(customSavePath, 'ru-hexlet-io-courses.html'));
    expect(minify(downloadedHTML, minifyConfig)).toBe(minify(changedHTML, minifyConfig));
    expect(downloadedImg).toBe(baseImg);
  });
});

describe('parse HTML', () => {
  beforeAll(async () => {
    try {
      baseHTML = await readFixture('htmlToDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlToDownload.html');
      throw new Error(error);
    }
    try {
      changedHTML = await readFixture('htmlAfterDownload.html');
    } catch (error) {
      console.log('Cannot load fixture file: htmlAfterDownload.html');
      throw new Error(error);
    }
  });

  test('create HTML, getImgSrcs, setImgSrc, get changed HTML', () => {
    const html = new ParsedHTML(baseHTML);
    expect(minify(html.toString(), minifyConfig)).toBe(minify(baseHTML, minifyConfig));
    const imagesSrcs = html.getImagesSrc();
    // console.log('images srcs before change: ', imagesSrcs);
    expect(imagesSrcs).toEqual(['assets/professions/nodejs.png']);
    html.setImagesSrc(['ru-hexlet-io-courses_files/ru-hexlet-io-assets-professions-nodejs.png']);
    expect(minify(html.toString(), minifyConfig)).toBe(minify(changedHTML, minifyConfig));
  });
});
